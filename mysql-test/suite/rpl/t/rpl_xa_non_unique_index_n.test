# The test proves that
#
# even though an XA-prepared transaction holds locks on
# non-unique index of modified records the following transactions are able
# to reach their target records while the XA-prepared one locks
# are in the way of scanning.
#
# REFERENCES
#
#    MDEV-33455 skip modified rows in parallel XA replication, don't wait
#    MDEV-34481 optimize away waiting for owned by prepared xa non-unique index
#    MDEV-34466 XA prepare don't release unmodified records for some cases
#
--source include/have_innodb.inc
--source include/have_debug.inc
--source include/have_debug_sync.inc
--source include/have_binlog_format_row.inc
--source include/master-slave.inc
#
# Legends:
# XAP_i := XA PREPARE,
# XAC_k := XA COMMIT
# _i,_k stand for an index ("logical" gtid seq_no) in binlog.
#
# The test checks
# 1.  the sequential slave executes XAP_1,XAP_2,XAP_3 followed by
#      their XA-Commits;
# 2a. ditto to the prallel optimistic;
# 2b. the prallel optimistic executes XAP_1(xid),XAC_2(xid),T3
#     so that T3 races ahead of its parent to reach wait-for-prior-commit;
# 2c. the parallel optimistic executes XAP_1(xid), T2, XAC_3(xid)
#     when T2 starts after XAP_1 has executed a pseudo-conflicting statement.
--echo *** Prepare load ***

--connection master
CREATE TABLE t1 (a int, b int, c int,
  INDEX i1(a),
  INDEX i2(b))
  ENGINE=InnoDB;
--source include/save_master_gtid.inc
--let $gtid_binlog_pos_0=$master_pos

INSERT INTO t1 VALUES
  (1,1,0), (1,2,0), (1,3,0), (1,4,0), (1,5,0),
  (2,1,0), (2,2,0),
  (3,1,0), (4,1,0), (5,1,0), (6,1,0), (7,1,0), (8,1,0), (9,1,0);
--sync_slave_with_master

--source include/stop_slave.inc
ALTER TABLE mysql.gtid_slave_pos ENGINE=innodb;
SET @old_timeout= @@GLOBAL.innodb_lock_wait_timeout;
SET @old_retries= @@GLOBAL.slave_transaction_retries;
SET GLOBAL innodb_lock_wait_timeout= 2;
SET GLOBAL slave_transaction_retries= 3;
--source include/start_slave.inc

--connection master
SET @@gtid_seq_no=100;
XA START "trx_1";
UPDATE t1 FORCE INDEX (i2) SET c=c+1 WHERE a=1 AND (b=1 OR b=2 OR b=5);
XA END "trx_1";
XA PREPARE "trx_1";

--connection master1
XA START "trx_2";
UPDATE t1 FORCE INDEX (i2) SET c=c+1 WHERE a=1 AND b=3;
XA END "trx_2";
XA PREPARE "trx_2";

--connect(master2,localhost,root,,)
--connection master2
XA START "trx_3";
UPDATE t1 FORCE INDEX (i2) SET c=c+1 WHERE a=1 AND b=4;
XA END "trx_3";
XA PREPARE "trx_3";

--connection master
XA COMMIT "trx_1";

--connection master1
XA COMMIT "trx_2";

--connection master2
XA COMMIT "trx_3";
--source include/save_master_gtid.inc
--let $gtid_binlog_pos_final = $master_pos

--connection master
SELECT * FROM t1 ORDER BY a,b,c;


--echo # 1. Sequential mode check

--sync_slave_with_master
SELECT * FROM t1 ORDER BY a,b,c;


--echo # 2.a Parallel mode check

# Rerun the DML part with slave worker threads
--connection slave
--source include/stop_slave.inc
delete from t1;
reset master;
--evalp set @@global.gtid_slave_pos='$gtid_binlog_pos_0'

set @old_slave_parallel_threads=@@global.slave_parallel_threads;
set @old_slave_parallel_mode=@@global.slave_parallel_mode;
set @@global.slave_parallel_threads=3;
set @@global.slave_parallel_mode=optimistic;
CHANGE MASTER TO master_use_gtid=slave_pos;
SET @@global.debug_dbug="+d,hold_worker_on_schedule";
--source include/start_slave.inc

# for deterministic run make sure the table filled up for next trx1..2 to act
--let $master_pos=$gtid_binlog_pos_0
--source include/sync_with_master_gtid.inc

--echo # trx:s wait for the parent one to complete its XA-prepare
--let $wait_condition= SELECT count(*) = 2 FROM information_schema.processlist WHERE state LIKE "Waiting for prior transaction to commit"
--source include/wait_condition.inc

# trx_1's wait for trx_2,3 to dock themselves in wait-for-prior-commit.
# Next prepare trx_2(seq_no=101) and trx_3 to hold on at before open tables
# until the predesessors trx_1,trx_2 respectively have released their extra
# locks at the end of xa-prepare.
# The subsequent two waits are necessary in order to avoid MDEV-34466.
# Specfically to not let concurrent lock acquision by latter trx while
# an earlier one though has released the former from w-f-p-c could still be
# in a phase of shaking off extra locks.
SET @@global.debug_dbug="+d,rows_log_event_before_open_table";
SET DEBUG_SYNC = 'now SIGNAL continue_worker';
--let $wait_condition= select count(*)=1 from information_schema.processlist where state like "%debug%"
--source include/wait_condition.inc
SELECT count(*) = 2 as 'assert: true' FROM information_schema.processlist WHERE state LIKE "Waiting for prior transaction to commit";
SET DEBUG_SYNC = 'now SIGNAL go_ahead_sql'; # to trx_1

# Possible trx_2's wait for trx_1 complete exit.
# As the selection of running indexes bases on engine statistics which the test
# is unable to control the actual index may be "sporadically" chosen to
# be the same non-conflicting one as on master. That's why the following wait
# condtions are defined with an '>=' ineqalities and two possible processlist
# states.
--let $wait_fail_do= SELECT * from mysql.gtid_slave_pos
--let $wait_condition= SELECT count(*) >= 1 FROM mysql.gtid_slave_pos WHERE seq_no >= 100
--source include/wait_condition.inc
--let $wait_condition= SELECT (select count(*) as cnt from  information_schema.processlist WHERE state LIKE "Waiting for work from SQL thread") = 3 or (select count(*) as cnt from  information_schema.processlist WHERE state LIKE "Waiting for prior transaction to commit") = 2
--source include/wait_condition.inc
SET DEBUG_SYNC = 'now SIGNAL go_ahead_sql'; # maybe to trx_2

# Possible trx_3's wait for trx_2 complete exit.
--let $wait_fail_do= SELECT * from mysql.gtid_slave_pos
--let $wait_condition= SELECT count(*) >= 1 FROM mysql.gtid_slave_pos WHERE seq_no >= 101
--source include/wait_condition.inc
SET DEBUG_SYNC = 'now SIGNAL go_ahead_sql'; # maybe to trx_3

--let $master_pos= $gtid_binlog_pos_final
--source include/sync_with_master_gtid.inc
SELECT * FROM t1 ORDER BY a,b,c;

--echo # 2.b XAP_1, XAC_2, T_3
# Prove that in parallel optimistic execution of a sequence of
#    XAP_1, XAC_2, T_3 where
# T_3 having to update a common record with the XA,
# and such that T3 races to reach wait-for-prior-commit ahead of XA starts on
# its job, it will anyway complete its job via standard retry.

--connection slave
SET DEBUG_SYNC = RESET;
SET @@global.debug_dbug="d,hold_worker_on_schedule";
# the where condition to update the table by XA
--let $t1_cond_2b = a=1 AND (b=1 OR b=2 OR b=3)
--connection master
# XAP_1
SET @save_domain_id=@@gtid_domain_id;
SET @@gtid_domain_id=34481; # for delay simulation by its XAC_2
SET @@gtid_seq_no=99;
XA START "trx_1";
--eval UPDATE t1 SET c=c+1 WHERE $t1_cond_2b
XA END "trx_1";
XA PREPARE "trx_1";
# XAC_2 is going to have seq_no = 100
XA COMMIT "trx_1";

--connection slave
# wait for XAP_1 done
--let $wait_condition= SELECT count(*) = 1 FROM mysql.gtid_slave_pos WHERE seq_no = 99
--source include/wait_condition.inc
--let $retry1= query_get_value(SHOW STATUS LIKE 'Slave_retried_transactions', Value, 1)

--connection master
# T_3
UPDATE t1 SET c=c+1 WHERE a=1 AND b=1;
--source include/save_master_gtid.inc
SET @@gtid_domain_id=@save_domain_id;

--connection slave
# ensure T_3 is in expected wait
--let $wait_condition= SELECT count(*) = 1 FROM information_schema.processlist WHERE state LIKE "Waiting for prior transaction to commit"
--source include/wait_condition.inc
# ongoing MDEV-31949 workaround, begin..
SET @@global.debug_dbug="+d,rows_log_event_before_open_table";

# ... release XAC_2
SET DEBUG_SYNC = 'now SIGNAL continue_worker';

# ..ongoing MDEV-31949 workaround, ends.
--let $wait_condition= select count(*) = 3 from t1 where $t1_cond_2b
--source include/wait_condition.inc
let $t1_cond_2b =;
SET DEBUG_SYNC = 'now SIGNAL go_ahead_sql'; # to T_3

--source include/sync_with_master_gtid.inc
--let $retry2= query_get_value(SHOW STATUS LIKE 'Slave_retried_transactions', Value, 1)
--evalp SELECT $retry1 + 1 = $retry2 as 'true'
SELECT * FROM t1 ORDER BY a,b,c;

--echo # 2.c XAP_1, T_2, XAC_3
# T_2 is trying to scan out its target index record when XAP_1 has processed
# that table but not yet got PREPAREd.
# Prove that T_2 is able to access it target index record without
# either wait of retry. In the non-fixed server case it would hang, retry
# and eventually error out.
--connection slave
SET DEBUG_SYNC = RESET;
SET @@global.debug_dbug="d,hold_worker_on_schedule";
--let $retry1= query_get_value(SHOW STATUS LIKE 'Slave_retried_transactions', Value, 1)

--connection master
create table t_pk (a int primary key, b int) engine=innodb;
INSERT INTO t_pk VALUES (1, 1);
--source include/save_master_gtid.inc

--connection slave
--source include/sync_with_master_gtid.inc
# prepare to block XAP_1 after the non-UK first statement
--source include/stop_slave.inc
SET GLOBAL innodb_lock_wait_timeout=100000;
--source include/start_slave.inc
--connection slave1
BEGIN;
  UPDATE t_pk SET b=b+2 WHERE a=1;

--connection master
# XAP_1
XA START "trx_1";
UPDATE t1 FORCE INDEX (i2) SET c=c+1 WHERE a=1 AND (b=1 OR b=2);
UPDATE t_pk SET b=b+1 WHERE a=1;
XA END "trx_1";
XA PREPARE "trx_1";

--connection slave
# verify XAP_1 locked out at the 2nd statement
--let $retry1= query_get_value(SHOW STATUS LIKE 'Slave_retried_transactions', Value, 1)
--let $table=information_schema.innodb_lock_waits
--let $count=1
--source include/wait_until_rows_count.inc

--connection master1
# T_2
UPDATE t1 FORCE INDEX (i2) SET c=c+1 WHERE a=1 AND b=3;
--connection master
# XAC_3
XA COMMIT "trx_1";
--source include/save_master_gtid.inc

--connection slave
--let $wait_condition= SELECT count(*) = 1 FROM information_schema.processlist WHERE state LIKE "Waiting for prior transaction to commit"
--source include/wait_condition.inc

--connection slave1
ROLLBACK;

--connection slave
--source include/sync_with_master_gtid.inc
SELECT * FROM t1 ORDER BY a,b,c;
--let $retry2= query_get_value(SHOW STATUS LIKE 'Slave_retried_transactions', Value, 1)
--evalp SELECT $retry1 = $retry2 as 'true: no retry'


--let $diff_tables=master:t1,slave:t1
--source include/diff_tables.inc
--let $diff_tables=master:t_pk,slave:t_pk
--source include/diff_tables.inc

# Cleanup
--connection master
DROP TABLE t_pk;
DROP TABLE t1;

--connection slave
SET GLOBAL innodb_lock_wait_timeout= @old_timeout;
SET GLOBAL slave_transaction_retries= @old_retries;
--source include/stop_slave.inc
SET debug_sync = RESET;
SET @@global.debug_dbug = "";
set @@global.slave_parallel_threads= @old_slave_parallel_threads;
set @@global.slave_parallel_mode= @old_slave_parallel_mode;
--source include/start_slave.inc

--source include/rpl_end.inc
