include/master-slave.inc
[connection master]
*** Prepare load ***
connection master;
CREATE TABLE t1 (a int, b int, c int,
INDEX i1(a),
INDEX i2(b))
ENGINE=InnoDB;
include/save_master_gtid.inc
INSERT INTO t1 VALUES
(1,1,0), (1,2,0), (1,3,0), (1,4,0), (1,5,0),
(2,1,0), (2,2,0),
(3,1,0), (4,1,0), (5,1,0), (6,1,0), (7,1,0), (8,1,0), (9,1,0);
connection slave;
include/stop_slave.inc
ALTER TABLE mysql.gtid_slave_pos ENGINE=innodb;
SET @old_timeout= @@GLOBAL.innodb_lock_wait_timeout;
SET @old_retries= @@GLOBAL.slave_transaction_retries;
SET GLOBAL innodb_lock_wait_timeout= 2;
SET GLOBAL slave_transaction_retries= 3;
include/start_slave.inc
connection master;
SET @@gtid_seq_no=100;
XA START "trx_1";
UPDATE t1 FORCE INDEX (i2) SET c=c+1 WHERE a=1 AND (b=1 OR b=2 OR b=5);
XA END "trx_1";
XA PREPARE "trx_1";
connection master1;
XA START "trx_2";
UPDATE t1 FORCE INDEX (i2) SET c=c+1 WHERE a=1 AND b=3;
XA END "trx_2";
XA PREPARE "trx_2";
connect master2,localhost,root,,;
connection master2;
XA START "trx_3";
UPDATE t1 FORCE INDEX (i2) SET c=c+1 WHERE a=1 AND b=4;
XA END "trx_3";
XA PREPARE "trx_3";
connection master;
XA COMMIT "trx_1";
connection master1;
XA COMMIT "trx_2";
connection master2;
XA COMMIT "trx_3";
include/save_master_gtid.inc
connection master;
SELECT * FROM t1 ORDER BY a,b,c;
a	b	c
1	1	1
1	2	1
1	3	1
1	4	1
1	5	1
2	1	0
2	2	0
3	1	0
4	1	0
5	1	0
6	1	0
7	1	0
8	1	0
9	1	0
# 1. Sequential mode check
connection slave;
SELECT * FROM t1 ORDER BY a,b,c;
a	b	c
1	1	1
1	2	1
1	3	1
1	4	1
1	5	1
2	1	0
2	2	0
3	1	0
4	1	0
5	1	0
6	1	0
7	1	0
8	1	0
9	1	0
# 2.a Parallel mode check
connection slave;
include/stop_slave.inc
delete from t1;
reset master;
set @@global.gtid_slave_pos='$gtid_binlog_pos_0';
set @old_slave_parallel_threads=@@global.slave_parallel_threads;
set @old_slave_parallel_mode=@@global.slave_parallel_mode;
set @@global.slave_parallel_threads=3;
set @@global.slave_parallel_mode=optimistic;
CHANGE MASTER TO master_use_gtid=slave_pos;
SET @@global.debug_dbug="+d,hold_worker_on_schedule";
include/start_slave.inc
include/sync_with_master_gtid.inc
# trx:s wait for the parent one to complete its XA-prepare
SET @@global.debug_dbug="+d,rows_log_event_before_open_table";
SET DEBUG_SYNC = 'now SIGNAL continue_worker';
SELECT count(*) = 2 as 'assert: true' FROM information_schema.processlist WHERE state LIKE "Waiting for prior transaction to commit";
assert: true
1
SET DEBUG_SYNC = 'now SIGNAL go_ahead_sql';
SET DEBUG_SYNC = 'now SIGNAL go_ahead_sql';
SET DEBUG_SYNC = 'now SIGNAL go_ahead_sql';
include/sync_with_master_gtid.inc
SELECT * FROM t1 ORDER BY a,b,c;
a	b	c
1	1	1
1	2	1
1	3	1
1	4	1
1	5	1
2	1	0
2	2	0
3	1	0
4	1	0
5	1	0
6	1	0
7	1	0
8	1	0
9	1	0
# 2.b XAP_1, XAC_2, T_3
connection slave;
SET DEBUG_SYNC = RESET;
SET @@global.debug_dbug="d,hold_worker_on_schedule";
connection master;
SET @save_domain_id=@@gtid_domain_id;
SET @@gtid_domain_id=34481;
SET @@gtid_seq_no=99;
XA START "trx_1";
UPDATE t1 SET c=c+1 WHERE a=1 AND (b=1 OR b=2 OR b=3);
XA END "trx_1";
XA PREPARE "trx_1";
XA COMMIT "trx_1";
connection slave;
connection master;
UPDATE t1 SET c=c+1 WHERE a=1 AND b=1;
include/save_master_gtid.inc
SET @@gtid_domain_id=@save_domain_id;
connection slave;
SET @@global.debug_dbug="+d,rows_log_event_before_open_table";
SET DEBUG_SYNC = 'now SIGNAL continue_worker';
SET DEBUG_SYNC = 'now SIGNAL go_ahead_sql';
include/sync_with_master_gtid.inc
SELECT $retry1 + 1 = $retry2 as 'true';
true
1
SELECT * FROM t1 ORDER BY a,b,c;
a	b	c
1	1	3
1	2	2
1	3	2
1	4	1
1	5	1
2	1	0
2	2	0
3	1	0
4	1	0
5	1	0
6	1	0
7	1	0
8	1	0
9	1	0
# 2.c XAP_1, T_2, XAC_3
connection slave;
SET DEBUG_SYNC = RESET;
SET @@global.debug_dbug="d,hold_worker_on_schedule";
connection master;
create table t_pk (a int primary key, b int) engine=innodb;
INSERT INTO t_pk VALUES (1, 1);
include/save_master_gtid.inc
connection slave;
include/sync_with_master_gtid.inc
include/stop_slave.inc
SET GLOBAL innodb_lock_wait_timeout=100000;
include/start_slave.inc
connection slave1;
BEGIN;
UPDATE t_pk SET b=b+2 WHERE a=1;
connection master;
XA START "trx_1";
UPDATE t1 FORCE INDEX (i2) SET c=c+1 WHERE a=1 AND (b=1 OR b=2);
UPDATE t_pk SET b=b+1 WHERE a=1;
XA END "trx_1";
XA PREPARE "trx_1";
connection slave;
connection master1;
UPDATE t1 FORCE INDEX (i2) SET c=c+1 WHERE a=1 AND b=3;
connection master;
XA COMMIT "trx_1";
include/save_master_gtid.inc
connection slave;
connection slave1;
ROLLBACK;
connection slave;
include/sync_with_master_gtid.inc
SELECT * FROM t1 ORDER BY a,b,c;
a	b	c
1	1	4
1	2	3
1	3	3
1	4	1
1	5	1
2	1	0
2	2	0
3	1	0
4	1	0
5	1	0
6	1	0
7	1	0
8	1	0
9	1	0
SELECT $retry1 = $retry2 as 'true: no retry';
true: no retry
1
include/diff_tables.inc [master:t1,slave:t1]
include/diff_tables.inc [master:t_pk,slave:t_pk]
connection master;
DROP TABLE t_pk;
DROP TABLE t1;
connection slave;
SET GLOBAL innodb_lock_wait_timeout= @old_timeout;
SET GLOBAL slave_transaction_retries= @old_retries;
include/stop_slave.inc
SET debug_sync = RESET;
SET @@global.debug_dbug = "";
set @@global.slave_parallel_threads= @old_slave_parallel_threads;
set @@global.slave_parallel_mode= @old_slave_parallel_mode;
include/start_slave.inc
include/rpl_end.inc
